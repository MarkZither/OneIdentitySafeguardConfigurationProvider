/*
 * Safeguard Core API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace OneIdentitySafeguard.Mock.Server.Models
{ 
    /// <summary>
    /// When the TypeReferenceName property is \&quot;Radius\&quot;, this provides additional RADIUS-specific  configuration values.
    /// </summary>
    [DataContract]
    public partial class IdentityProviderConfigRadiusProperties : IEquatable<IdentityProviderConfigRadiusProperties>
    { 
        /// <summary>
        /// The IP address or FQDN of the primary RADIUS server. (required for radius providers)
        /// </summary>
        /// <value>The IP address or FQDN of the primary RADIUS server. (required for radius providers)</value>

        [MaxLength(255)]
        [DataMember(Name="ServerAddress1")]
        public string ServerAddress1 { get; set; }

        /// <summary>
        /// The IP address or FQDN of the backup RADIUS server.
        /// </summary>
        /// <value>The IP address or FQDN of the backup RADIUS server.</value>

        [MaxLength(255)]
        [DataMember(Name="ServerAddress2")]
        public string ServerAddress2 { get; set; }

        /// <summary>
        /// The port number to use for connections to the RADIUS servers.  (required for radius providers)
        /// </summary>
        /// <value>The port number to use for connections to the RADIUS servers.  (required for radius providers)</value>

        [Range(1, 65535)]
        [DataMember(Name="ServerPort")]
        public int? ServerPort { get; set; }

        /// <summary>
        /// The shared secret used to hash RADIUS user passwords. This value is typically provided by a RADIUS system administrator.  (required for radius providers)
        /// </summary>
        /// <value>The shared secret used to hash RADIUS user passwords. This value is typically provided by a RADIUS system administrator.  (required for radius providers)</value>

        [MaxLength(255)]
        [DataMember(Name="SharedSecret")]
        public string SharedSecret { get; set; }

        /// <summary>
        /// The time (specified in seconds) to wait for a response from the RADIUS server before retrying.
        /// </summary>
        /// <value>The time (specified in seconds) to wait for a response from the RADIUS server before retrying.</value>

        [Range(1, 300)]
        [DataMember(Name="Timeout")]
        public int? Timeout { get; set; }

        /// <summary>
        /// The number of times to retry RADIUS server requests before giving up.
        /// </summary>
        /// <value>The number of times to retry RADIUS server requests before giving up.</value>

        [Range(0, 10)]
        [DataMember(Name="Retries")]
        public int? Retries { get; set; }

        /// <summary>
        /// Indicates whether an Access-Request call containing only the User-Name should be sent to the RADIUS server              prior to the user&#x27;s authentication attempt.  This is done to inform the RADIUS server of the user&#x27;s identity so it              can possibly begin the authentication process by starting a challenge/response cycle.  This may be required to seed              the user&#x27;s state data.  In addition, the RADIUS server&#x27;s response may include a login message that is to be displayed,              which is specific to that user.  Note, if the RADIUS server is not configured to respond with an Access-Challenge,              then this will cause the log in to fail and the user will be unable to proceed.
        /// </summary>
        /// <value>Indicates whether an Access-Request call containing only the User-Name should be sent to the RADIUS server              prior to the user&#x27;s authentication attempt.  This is done to inform the RADIUS server of the user&#x27;s identity so it              can possibly begin the authentication process by starting a challenge/response cycle.  This may be required to seed              the user&#x27;s state data.  In addition, the RADIUS server&#x27;s response may include a login message that is to be displayed,              which is specific to that user.  Note, if the RADIUS server is not configured to respond with an Access-Challenge,              then this will cause the log in to fail and the user will be unable to proceed.</value>

        [DataMember(Name="PreAuthenticateForChallengeResponse")]
        public bool? PreAuthenticateForChallengeResponse { get; set; }

        /// <summary>
        /// If enabled, the text box that the user enters their one-time password, or other challenge required by the              RADIUS server, will always be a password style text box in which the user&#x27;s input is masked, i.e. appears as a series              of dots, not as clear text.  This may be desired when the challenge is not just a one-time password, but also contains              the user&#x27;s PIN.  This will prevent any passer-by from seeing the private information.  Note, however, that when this              setting is enabled, it will also override the Prompt attribute of the RADIUS server&#x27;s Access-Challenge response, such              that the user&#x27;s input will always be masked.
        /// </summary>
        /// <value>If enabled, the text box that the user enters their one-time password, or other challenge required by the              RADIUS server, will always be a password style text box in which the user&#x27;s input is masked, i.e. appears as a series              of dots, not as clear text.  This may be desired when the challenge is not just a one-time password, but also contains              the user&#x27;s PIN.  This will prevent any passer-by from seeing the private information.  Note, however, that when this              setting is enabled, it will also override the Prompt attribute of the RADIUS server&#x27;s Access-Challenge response, such              that the user&#x27;s input will always be masked.</value>

        [DataMember(Name="AlwaysMaskUserInput")]
        public bool? AlwaysMaskUserInput { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class IdentityProviderConfigRadiusProperties {\n");
            sb.Append("  ServerAddress1: ").Append(ServerAddress1).Append("\n");
            sb.Append("  ServerAddress2: ").Append(ServerAddress2).Append("\n");
            sb.Append("  ServerPort: ").Append(ServerPort).Append("\n");
            sb.Append("  SharedSecret: ").Append(SharedSecret).Append("\n");
            sb.Append("  Timeout: ").Append(Timeout).Append("\n");
            sb.Append("  Retries: ").Append(Retries).Append("\n");
            sb.Append("  PreAuthenticateForChallengeResponse: ").Append(PreAuthenticateForChallengeResponse).Append("\n");
            sb.Append("  AlwaysMaskUserInput: ").Append(AlwaysMaskUserInput).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((IdentityProviderConfigRadiusProperties)obj);
        }

        /// <summary>
        /// Returns true if IdentityProviderConfigRadiusProperties instances are equal
        /// </summary>
        /// <param name="other">Instance of IdentityProviderConfigRadiusProperties to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(IdentityProviderConfigRadiusProperties other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    ServerAddress1 == other.ServerAddress1 ||
                    ServerAddress1 != null &&
                    ServerAddress1.Equals(other.ServerAddress1)
                ) && 
                (
                    ServerAddress2 == other.ServerAddress2 ||
                    ServerAddress2 != null &&
                    ServerAddress2.Equals(other.ServerAddress2)
                ) && 
                (
                    ServerPort == other.ServerPort ||
                    ServerPort != null &&
                    ServerPort.Equals(other.ServerPort)
                ) && 
                (
                    SharedSecret == other.SharedSecret ||
                    SharedSecret != null &&
                    SharedSecret.Equals(other.SharedSecret)
                ) && 
                (
                    Timeout == other.Timeout ||
                    Timeout != null &&
                    Timeout.Equals(other.Timeout)
                ) && 
                (
                    Retries == other.Retries ||
                    Retries != null &&
                    Retries.Equals(other.Retries)
                ) && 
                (
                    PreAuthenticateForChallengeResponse == other.PreAuthenticateForChallengeResponse ||
                    PreAuthenticateForChallengeResponse != null &&
                    PreAuthenticateForChallengeResponse.Equals(other.PreAuthenticateForChallengeResponse)
                ) && 
                (
                    AlwaysMaskUserInput == other.AlwaysMaskUserInput ||
                    AlwaysMaskUserInput != null &&
                    AlwaysMaskUserInput.Equals(other.AlwaysMaskUserInput)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (ServerAddress1 != null)
                    hashCode = hashCode * 59 + ServerAddress1.GetHashCode();
                    if (ServerAddress2 != null)
                    hashCode = hashCode * 59 + ServerAddress2.GetHashCode();
                    if (ServerPort != null)
                    hashCode = hashCode * 59 + ServerPort.GetHashCode();
                    if (SharedSecret != null)
                    hashCode = hashCode * 59 + SharedSecret.GetHashCode();
                    if (Timeout != null)
                    hashCode = hashCode * 59 + Timeout.GetHashCode();
                    if (Retries != null)
                    hashCode = hashCode * 59 + Retries.GetHashCode();
                    if (PreAuthenticateForChallengeResponse != null)
                    hashCode = hashCode * 59 + PreAuthenticateForChallengeResponse.GetHashCode();
                    if (AlwaysMaskUserInput != null)
                    hashCode = hashCode * 59 + AlwaysMaskUserInput.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(IdentityProviderConfigRadiusProperties left, IdentityProviderConfigRadiusProperties right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(IdentityProviderConfigRadiusProperties left, IdentityProviderConfigRadiusProperties right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
